[{"/Users/Sanju/Trabajo/training/Teaching/demo/src/reportWebVitals.js":"1","/Users/Sanju/Trabajo/training/Teaching/demo/src/Board.js":"2","/Users/Sanju/Trabajo/training/Teaching/demo/src/index.js":"3","/Users/Sanju/Trabajo/training/Teaching/demo/src/Game.js":"4"},{"size":362,"mtime":1606653906761,"results":"5","hashOfConfig":"6"},{"size":5025,"mtime":1613329043758,"results":"7","hashOfConfig":"6"},{"size":503,"mtime":1612723964243,"results":"8","hashOfConfig":"6"},{"size":2897,"mtime":1617818724252,"results":"9","hashOfConfig":"6"},{"filePath":"10","messages":"11","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"12"},"eysh3s",{"filePath":"13","messages":"14","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"15"},{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/Sanju/Trabajo/training/Teaching/demo/src/reportWebVitals.js",[],["21","22"],"/Users/Sanju/Trabajo/training/Teaching/demo/src/Board.js",["23","24"],"import React from \"react\"\nimport Square from \"./Square\"\n\nclass Board extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            squares: Array(9).fill({ letter: null, color: \"black\" }),\n            xNext: true,\n            finished: false,\n            //Guardamos el ganador en el estado\n            winner: null,\n        };\n    }\n\n    maybeRenderRestart() {\n        if (this.state.finished) {\n            return <button onClick={() => this.reset()}> restart\n          </button>\n        }\n    }\n\n    //Controlamos el fin del juego en una única función\n    //Esta función se encargará de gestionar el estado para determinar si se ha acabado y si hay un ganador\n    checkFinished(squares) {\n        if (this.state.finished) {\n            //Si ya estaba acabado sigue acabado\n            return true\n        }\n        let winner = this.calculateWinner(squares)\n        if (winner) {\n            //Si hay un ganador, lo guardamos en el estado\n            this.setState({\n                finished: true,\n                winner: winner\n            })\n            return true\n        }\n        for (let i = 0; i < squares.length; i++) {\n            if (squares[i].letter === null) {\n                return false\n            }\n        }\n        // Si no quedan casillas libres, el juego se ha acabado sin ganador\n        this.setState({\n            finished: true,\n            winner: null\n        })\n        return true\n    }\n\n    reset() {\n        this.setState({\n            squares: Array(9).fill({ letter: null, color: \"black\" }),\n            xNext: true,\n            finished: false,\n            //Recordamos resetear el ganador para la proxima partida\n            winner: null,\n        })\n    }\n\n    mark(i) {\n        let squares = this.state.squares\n        // Se puede mover ficha si el juego no ha terminado y la casilla está vacía. Sabemos si está terminado directamente del estado.\n        if (!this.state.finished && !squares[i].letter) {\n            squares[i] = this.getTurn()\n            this.setState({ squares: squares, xNext: !this.state.xNext })\n            //Comprobamos si se acaba el juego después de marcar\n            this.checkFinished(squares)\n        }\n    }\n\n    renderSquare(i) {\n        return <Square value={this.state.squares[i].letter} checkSquare={() => this.mark(i)} color={this.state.squares[i].color} />;\n    }\n\n    getTurn() {\n        if (this.state.xNext) {\n            return { letter: \"X\", color: \"blue\" };\n        }\n        return { letter: \"O\", color: \"orange\" };\n    }\n\n    calculateWinner(squares) {\n        const lines = [\n            [0, 1, 2],\n            [3, 4, 5],\n            [6, 7, 8],\n            [0, 3, 6],\n            [1, 4, 7],\n            [2, 5, 8],\n            [0, 4, 8],\n            [2, 4, 6],\n        ];\n        for (let i = 0; i < lines.length; i++) {\n            const [a, b, c] = lines[i];\n            if (squares[a].letter && squares[a].letter === squares[b].letter && squares[a].letter === squares[c].letter) {\n                this.props.winFunction(squares[a].letter)\n                squares[a].color = \"red\"; squares[b].color = \"red\"; squares[c].color = \"red\"\n                // no es seguro comparar objetos con el triple = ; usar función equals que implementan los objetos para ver si son igual, pero es un poco más incómodo. difici establecer el criterio que los hace iguales. EJ: coche : modelos, gama, color, etc...\n                return squares[a];\n            }\n        }\n        return null;\n    }\n\n    renderStatus() {\n        //Determinamos si se ha acabado leyendo el estado\n        if (this.state.finished) {\n            if (this.state.winner) {\n                //Obtenemos al ganador leyendo del estado\n                return <div>Winner: <a style={{ color: this.state.winner.color }}>\n                    {this.state.winner.letter}</a>\n                </div>\n            } else {\n                return \"Game Finished: Draw\"\n            }\n        } else {\n            return <div>Next player: <a style={{ color: this.getTurn().color }}>{this.getTurn().letter}</a></div>\n        }\n    }\n\n    render() {\n        let status = this.renderStatus()\n        return (\n            <div>\n                <div className=\"status\">{status}</div>\n                <div className=\"board-row\">\n                    {this.renderSquare(0)}\n                    {this.renderSquare(1)}\n                    {this.renderSquare(2)}\n                </div>\n                <div className=\"board-row\">\n                    {this.renderSquare(3)}\n                    {this.renderSquare(4)}\n                    {this.renderSquare(5)}\n                </div>\n                <div className=\"board-row\">\n                    {this.renderSquare(6)}\n                    {this.renderSquare(7)}\n                    {this.renderSquare(8)}\n                </div>\n                <div button=\"restart\">\n                    {this.maybeRenderRestart()}\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default Board","/Users/Sanju/Trabajo/training/Teaching/demo/src/index.js",[],["25","26"],"/Users/Sanju/Trabajo/training/Teaching/demo/src/Game.js",[],{"ruleId":"27","replacedBy":"28"},{"ruleId":"29","replacedBy":"30"},{"ruleId":"31","severity":1,"message":"32","line":112,"column":37,"nodeType":"33","endLine":112,"endColumn":83},{"ruleId":"31","severity":1,"message":"32","line":119,"column":38,"nodeType":"33","endLine":119,"endColumn":81},{"ruleId":"27","replacedBy":"34"},{"ruleId":"29","replacedBy":"35"},"no-native-reassign",["36"],"no-negated-in-lhs",["37"],"jsx-a11y/anchor-is-valid","The href attribute is required for an anchor to be keyboard accessible. Provide a valid, navigable address as the href value. If you cannot provide an href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement",["36"],["37"],"no-global-assign","no-unsafe-negation"]